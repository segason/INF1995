#include "Memoire24CXXX.h"
#include "delControl.h" 
#include "Moteur.h" 
#include "can.h"
#include "minuterie.h" 
#include "Memoire24CXXX.h" 
#include "PwmSon.h"
#include "PWM.h"
#include <avr/io.h>
#include <avr/interrupt.h> 
#define F_CPU 8000000
#include <util/delay.h>
using namespace std;

/*
struct Tableau
{
    uint8_t tableau[2];
};
*/


void initialisationUART ( void ) {

// 2400 bauds. Nous vous donnons la valeur des deux

// premier registres pour vous éviter des complications

UBRR0H = 0;

UBRR0L = 0xCF;

// permettre la reception et la transmission par le UART0

UCSR0A = (1 << TXC0) | (1 << RXC0) ;

UCSR0B =  (1 << RXEN0) | (1 << TXEN0) ; // L'émetteur USART est activé en réglant TXEN dans UCSRB.

// Format des trames: 8 bits, 1 stop bits, none parity

UCSR0C = (1 << UCSZ00) | (1 << UCSZ01);

}

// De l'USART vers le PC


void lecture(Memoire24CXXX& memoire, uint8_t& adresse, 
uint8_t& inst, uint8_t& operande)
{
	_delay_ms(5);
	memoire.lecture(adresse, inst, 1);
	memoire.lecture(adresse + 1, operande, 1);
}

/*
void transmissionUARTVersPc ( uint8_t donnee ) {

	while (!( UCSR0A & (1<<UDRE0))) //Attendre que le tampon soient libre. 
	{
	}
               
    	UDR0 = donnee; 
*/
char transmissionPcVersUart ( ) {

	while (!( UCSR0A & (1<<RXC0)) && !(PIND & 0x04)) //
	{
	}
               
    	return UDR0;//Retourne le data recu par lwe buffer

}


void faireSon(unsigned int midi)
{
	TCCR0A = (1 << WGM01) | (1 << COM0A0);
	TCCR0B = 0x04 ;
	
	if(midi >= 45 && midi <= 81)
		OCR0A = 15625.0/(110.0 * pow(2, (midi-45)/12.0));
		
	if(midi == 0)
		OCR0A = 0;
		
}





int main()
{
    DDRA = 0xFF;
	DDRB = 0xFF;
	DDRD = 0b11110000;
	
    Del del;
    Memoire24CXXX memoire;
	memoire.init();
        
	
        
        
        initialisationUART();
        
        uint8_t tableau[255];
        tableau[0] = transmissionPcVersUart();
        tableau[1] = transmissionPcVersUart();
        
        uint16_t taille = (tableau[0] << 8) | tableau[1];
        
        for (int i = 2; i < taille; i++){
            tableau[i] = transmissionPcVersUart();
        }
        
        for (int i = 2; i < taille; i++){
            memoire.ecriture(i , tableau[i]);
            _delay_ms(5);
            del.allumerRouge(0);
            _delay_ms(25);
            PORTA = 0x00;
            _delay_ms(25);
        }
         
   //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////       
    uint8_t adresse = 0x02;
	uint8_t adresseBoucle;
	uint8_t repBoucle;
	uint8_t compteur;
	
	uint8_t operande;
	uint8_t instruction;
	
	enum Etat{ON, OFF};
	Etat monEtat = ON;
	
	Pwm moteur;

        
	//Sequence de demarrage
	for(uint8_t i = 0; i < 3; i++)
	{
            del.allumerRouge(0);
            faireSon(69);
            _delay_ms(500);
            faireSon(0);
            del.allumerVert(0);
            faireSon(45);
            _delay_ms(500);
            faireSon(0);
	}
	del.eteindreDel();
	
	while (instruction != 0x01)	//recherche de l'instruction de debut
	{
		lecture(memoire, adresse, instruction, operande);
		adresse += 2;
	}
        
	while(monEtat != OFF)
        {
            lecture(memoire, adresse, instruction, operande);

            switch (instruction)
            {     
                    case (0x02):	//Attendre
						for(uint8_t i = 0; i < operande; i++)
							_delay_ms(25);
                    break;
                    
                    case (0x44):	//Allumer la del
                        del.allumerVert(0);
                    break;
                    
                    case (0x45):	//Eteindre la del
                        del.eteindreDel();
                    break;
                    
                    case (0x48):	//faire son
						faireSon(operande);
                    
                    break;
                    
                    case (0x09):	//eteindre son
                        faireSon(0);
   
                    break;
                    
                    case (0x60):	//eteindre moteur
						moteur.Avance(0);
                    break;
                    
                     case (0x61):	//eteindre moteur
						moteur.Avance(0);
                    break;
                    
                    case (0x62):	//avance
						moteur.Avance(operande);
                    break;
                    
                    case (0x63):	//recule
						moteur.reculer(operande);
                    break;
                    
                    case (0x64):	//tourne a droite
						moteur.Tourner_Droite(128);
                    break;
                    
                    case (0x65):	//tourne a gauche
						moteur.Tourner_Gauche(128);
                    break;
                    
                    case (0xC0):	//debut boucle
                         adresseBoucle = adresse;
                         RepBoucle = operande;
                         compteur = 0;  
                    break;
                    
                    case (0xC1):	//fin boucle
                         if(compteur < repBoucle)
                         {
							adresse = adresseBoucle;
							compteur++;
                         }
                    break;
                    
                    case (0xFF):	//fin
                            monEtat = OFF;
                    break;
            }
            adresse += 2;

        }	
	
	
	return 0;
}

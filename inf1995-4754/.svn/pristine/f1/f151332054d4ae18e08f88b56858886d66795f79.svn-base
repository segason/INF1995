#include "Memoire24CXXX.h"
#include "delControl.h" 
#include "Moteur.h" 
#include "can.h"
#include "minuterie.h" 
#include "Memoire24CXXX.h" 
#include "PwmSon.h"
#include "PWM.h"
#include <avr/io.h>
#include <avr/interrupt.h> 
#define F_CPU 8000000
#include <util/delay.h>
using namespace std;

/*
///////////// BOUTONS DE DIRECTION ///////////////

    char directions[3] = {};
    uint8_t compteur = 0;
    bool enfonceDroit = false;
    bool enfonceGauche = false;
    DDRB = 0b11111100;
    
	while (compteur<3) {
	
		switch (compteur) {
		case 0:
			if (!(PINB & 0x01)) { 	//bouton droit
				_delay_ms(10);
				if(!(PINB & 0x01)){
					enfonceDroit = true;
					_delay_ms(10);
				}
			}
			else
				if(enfonceDroit){
					enfonceDroit = false;
					directions[0] = 'd';
					compteur++;
				}
				
			if (!(PINB & 0x02)) { 		//bouton gauche
				_delay_ms(10);
				if(!(PINB & 0x02)){
					enfonceGauche = true;
					_delay_ms(10);
				}
			}
			else
				if(enfonceGauche){
					enfonceGauche = false;
					directions[0] = 'g';
					compteur++;
				}
				
			break;

	
		case 1:
			if (!(PINB & 0x01)) { 	//bouton droit	
				_delay_ms(10);
				if(!(PINB & 0x01)){
					enfonceDroit = true;
					_delay_ms(10);
				}
			}
			else
				if(enfonceDroit){
					enfonceDroit = false;
					directions[1] = 'd';
					compteur++;
				}
				
			if (!(PINB & 0x02)) { 		//bouton gauche
				_delay_ms(10);
				if(!(PINB & 0x02)){
					enfonceGauche = true;
					_delay_ms(10);
				}
			}
			else
				if(enfonceGauche){
					enfonceGauche = false;
					directions[1] = 'g';
					compteur++;
				}
			break;

	
		case 2:
			if (!(PINB & 0x01)) { 	//bouton droit	
				_delay_ms(10);
				if(!(PINB & 0x01)){
					enfonceDroit = true;
					_delay_ms(10);
				}
			}
			else
				if(enfonceDroit){
					enfonceDroit = false;
					directions[2] = 'd';
					compteur++;
				}
				
			if (!(PINB & 0x02)) { 		//bouton gauche
				_delay_ms(10);
				if(!(PINB & 0x02)){
					enfonceGauche = true;
					_delay_ms(10);
				}
			}
			else
				if(enfonceGauche){
					enfonceGauche = false;
					directions[2] = 'g';
					compteur++;
				}
			break;


		}
	}
*/






/*Capteurs:
PINC & 0b00010000   capteur_droit
PINC & 0b00000001   capteur_gauche
PINC & 0b00000010   centre capteur_gauche
PINC & 0b00001000   centre droit
PINC & 0b00000100   centre
 
 */

//!(x^y) 00011111   00011111 & 0x01  0z02
int main()
{
    
    DDRA = 0xff;
    DDRD = 0b11110000;
    DDRC = 0x00;
    Del del;
    Pwm moteur;
    bool aTourneAGauche = false;
    bool aTourneADroite = false;
    bool bit1 = false, bit2 = false, bit3 = false, bit4 = false, bit5 = false;
    while (true)
    {
        bit1 = PINC & 0b00000001;
        bit2 = PINC & 0b00000010;
        bit3 = PINC & 0b00000100;
        bit4 = PINC & 0b00001000;
        bit5 = PINC & 0b00010000;
        
        if(bit1 && !(bit2 && bit3 && bit4 && bit5))
        {
            moteur.Tourner_Gauche(120);
        }
        else if (!(bit1 && bit2 && bit3 && bit4) && bit5)
        {
            moteur.Tourner_Droite(120);
        }
        
        else{
            moteur.Avance(90);
        }
        
    }
    
    
    
}
/*
struct Tableau
{
    uint8_t tableau[2];
};



void initialisationUART ( void ) {

// 2400 bauds. Nous vous donnons la valeur des deux

// premier registres pour vous éviter des complications

UBRR0H = 0;

UBRR0L = 0xCF;

// permettre la reception et la transmission par le UART0

UCSR0A = (1 << TXC0) | (1 << RXC0) ;

UCSR0B =  (1 << RXEN0) | (1 << TXEN0) ; // L'émetteur USART est activé en réglant TXEN dans UCSRB.

// Format des trames: 8 bits, 1 stop bits, none parity

UCSR0C = (1 << UCSZ00) | (1 << UCSZ01);

}

// De l'USART vers le PC


Tableau lecture(Memoire24CXXX& memoire, uint8_t& adresse)
{
	_delay_ms(5);
	uint8_t instruction[2] = {};
	memoire.lecture(adresse, instruction, 2);
	
        Tableau monTableau;
        monTableau.tableau[0] = instruction[0];
        monTableau.tableau[1] = instruction[1];
	return monTableau;
}
/*
uint8_t lecture(Memoire24CXXX& memoire, uint8_t& adresse)
{
	_delay_ms(5);
	uint8_t instruction[2] = {};
	memoire.lecture(adresse, instruction, 2);
	adresse += 2;
	
	return instruction[2];
}
*//*
void transmissionUARTVersPc ( uint8_t donnee ) {

	while (!( UCSR0A & (1<<UDRE0))) //Attendre que le tampon soient libre. 
	{
	}
               
    	UDR0 = donnee; 

}*/
/*
char transmissionPcVersUart ( ) {

	while (!( UCSR0A & (1<<RXC0)) && !(PIND & 0x04)) //
	{
	}
               
    	return UDR0;//Retourne le data recu par lwe buffer

}


void faireSon(unsigned int pwm)
{
        TCCR0A = (1 << WGM01) | (1 << COM0A0);
	
	TCCR0B = 0x04 ;
		
	OCR0A = 15625.0/(110.0 * pow(2, (pwm-45)/12.0));
}





int main()
{
	DDRB = 0xFF;
	DDRD = 0B11110000;
        Del del;
        Memoire24CXXX memoire;
	memoire.init();
        
	
        
        
        initialisationUART();
        
        uint8_t tableau[255];
        tableau[0] = transmissionPcVersUart();
        tableau[1] = transmissionPcVersUart();
        
        uint16_t taille = (tableau[0] << 8) | tableau[1];
        
        for (int i = 2; i < taille; i++){
            tableau[i] = transmissionPcVersUart();
        }
        
        for (int i = 2; i < taille; i++){
            memoire.ecriture(i , tableau[i]);
            _delay_ms(5);
            del.allumerRouge(0);
            _delay_ms(25);
            del.eteindreDel();
            _delay_ms(25);
        }
         
   //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////       
        uint8_t adresse = 0x02;
	uint8_t adresseBoucle;
	uint8_t repBoucle;
	uint8_t compteur;
	uint8_t inst[2];
	enum Etat{ON, OFF, END};
	Etat monEtat = OFF;
	
	Pwm moteur;

        
	//Sequence de demarrage
	for(uint8_t i = 0; i < 3; i++)
	{
            del.allumerRouge(0);
            _delay_ms(500);
            del.allumerVert(0);
            _delay_ms(500);
	}
	
	del.eteindreDel();
        
	while(monEtat != END)
        {
            Tableau tab = lecture(memoire, adresse);
           
            inst[0] = tab.tableau[0];
               inst[1] = tab.tableau[1];
            switch (inst[0])
            { //Utiliser element 2 au besoin
                    case (0x01):
                            monEtat = ON;
                            break;
                            
                    case (0x02):
                            if(monEtat == ON)
                                for(uint8_t i = 0; i < inst[1]; i++)
                                    _delay_ms(25);
                    break;
                    
                    case (0x44):
                            if(monEtat == ON)
                                    del.allumerVert(0);
                    break;
                    
                    case (0x45):
                            if(monEtat == ON)
                                del.eteindreDel();
                    break;
                    
                    case (0x48):
                            if(monEtat == ON)
                                faireSon(inst[1]);
                    
                    break;
                    
                    case (0x09):
                            if(monEtat == ON)
                                faireSon(0);
   
                    break;
                    
                    case (0x60):
                            if(monEtat == ON)
                                moteur.Avance(0);
                    break;
                    
                     case (0x61):
                            if(monEtat == ON)
                                moteur.Avance(0);
                                
                    break;
                    
                    case (0x62):
                            if(monEtat == ON)
                                moteur.Avance(inst[1]);
                    break;
                    
                    case (0x63):
                            if(monEtat == ON)
                                moteur.reculer(inst[1]);
                    break;
                    
                    case (0x64):
                            if(monEtat == ON)
                                moteur.Tourner_Droite(128);
                    break;
                    
                    case (0x65):
                            if(monEtat == ON)
                                moteur.Tourner_Gauche(128);
                    break;
                    
                    case (0xC0):
                            if(monEtat == ON)
                            {
                                  adresseBoucle = adresse;
                                  repBoucle = inst[1];
                                  compteur = 0;  
                            }
                    break;
                    
                    case (0xC1):
                            if(monEtat == ON)
                            {
                                if(compteur < repBoucle)
                                {
					adresse = adresseBoucle;
					compteur++;
                                }
                            }
                    break;
                    
                    case (0xFF):
                            monEtat = END;
                    break;
            }
            adresse += 2;

        }	
	
	
	return 0;
}
*/

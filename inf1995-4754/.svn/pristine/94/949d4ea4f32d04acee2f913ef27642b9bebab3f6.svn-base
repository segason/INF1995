#include "Memoire24CXXX.h"
#include "delControl.h" 
#include "Moteur.h" 
#include "can.h"
#include "minuterie.h" 
#include "Memoire24CXXX.h" 
#include "PwmSon.h"
#include "PWM.h"
#include <avr/io.h>
#include <avr/interrupt.h> 
#define F_CPU 8000000
#include <util/delay.h>
using namespace std;
    volatile bool bit1 = false, bit2 = false, bit3 = false, bit4 = false, bit5 = false;

/*Capteurs:
PINC & 0b00010000   capteur_droit
PINC & 0b00000001   capteur_gauche
PINC & 0b00000010   centre capteur_gauche
PINC & 0b00001000   centre droit
PINC & 0b00000100   centre
 
 */
void faireSon(unsigned int pwm)
{
       if(pwm >= 45)
       {
        TCCR0A = (1 << WGM01) | (1 << COM0A0);
	
	TCCR0B = 0x04 ;
		
	OCR0A = 15625.0/(110.0 * pow(2, (pwm-45)/12.0));
       }
       else
        {
            TCCR0A = (1 << WGM01) | (1 << COM0A0);
	
            TCCR0B = 0x04 ;
		
            OCR0A = 0;
       }
}

void initialisationUART ( void ) {

// 2400 bauds. Nous vous donnons la valeur des deux

// premier registres pour vous éviter des complications

UBRR0H = 0;

UBRR0L = 0xCF;

// permettre la reception et la transmission par le UART0

UCSR0A = (1 << TXC0) | (1 << RXC0) ;

UCSR0B =  (1 << RXEN0) | (1 << TXEN0) ; // L'émetteur USART est activé en réglant TXEN dans UCSRB.

// Format des trames: 8 bits, 1 stop bits, none parity

UCSR0C = (1 << UCSZ00) | (1 << UCSZ01);

}

void transmissionUARTVersPc ( uint8_t donnee ) {

	while (!( UCSR0A & (1<<UDRE0))) //Attendre que le tampon soient libre. 
	{
	}
               
    	UDR0 = donnee; 
}
void lireDirection()
{
        bit1 = PINC & 0b00000001;
        bit2 = PINC & 0b00000010;
        bit3 = PINC & 0b00000100;
        bit4 = PINC & 0b00001000;
        bit5 = PINC & 0b00010000;
}
//!(x^y) 00011111   00011111 & 0x01  0z02 (stuff de godalol)
int main()
{
    
    DDRD = 0b11110000;
    DDRC = 0x00;
    DDRA = 0x0F;
    Del del;
    Pwm moteur;
    can intensite;
    uint8_t rapport;
    //bool aTourneAGauche = false;
    //bool aTourneADroite = false;
    bool passeDansLeTunel = false;
    bool estSortiDuTunel = false;
    initialisationUART();
    
///////////// BOUTONS DE DIRECTION ///////////////
    char directions[3] = {};
    uint8_t compteur = 0;
    uint8_t compteurIntersections = 0;
    bool enfonceDroit = false;
    bool enfonceGauche = false;
    uint8_t petitSkip = 0;
    DDRB = 0b11111100;
    
	while (compteur<3) 
        {
			if (!(PINB & 0x01)) { 	//bouton droit
				_delay_ms(10);
				if(!(PINB & 0x01)){
					enfonceDroit = true;
                                        PORTA = 0b1000;
					_delay_ms(10);
				}
			}
			else if (!(PINB & 0x02)) 
                        { 		//bouton gauche
				_delay_ms(10);
				if(!(PINB & 0x02))
                                {
					enfonceGauche = true;
                                         PORTA = 0b0100;
					_delay_ms(10);
				}
			}
			else if(enfonceDroit)
                        {
                            enfonceDroit = false;
                            PORTA = 0x00;
                            directions[compteur] = 'g';
                            compteur++;
                        }
			else if(enfonceGauche)
                        {
                            enfonceGauche = false;
                            PORTA = 0x00;
                            directions[compteur] = 'd';
                            compteur++;
                        }
				
        }

	
		
	
////////////// FIN DE DETECTION DE BOUTONS /////////////////////
 
 
 
    compteur = 0;
    while (true)
    {
        ////////////////// SOYA GIRL SUPER ADDONS ///////////////////////////
        rapport = intensite.lecture(6) >> 2;  //LIRE SUR LE BON PORT  
        lireDirection();
     
    
            //transmissionUARTVersPc(directions[i]);
    
       /*
        if(compteurIntersections > 0 && ) //En gros s'il a fait les intersections et autre condition pas trouvée alors il est rendu au carré
        {}*/
         /*if(petitSkip >= 7)
            faireSon(0);   // Il y a 7 petitSkip dans le circuit, donc si tout marche bein le son devrait arrêter là.
       */
            
        //    if(!estSortiDuTunel)
         //   {
                if(rapport < 80 /*&& !estSortiDuTunel*/)
                {
                    //_delay_ms(200);
                   // rapport = intensite.lecture(6) >> 2; 
                    //if(rapport < 80)
                   // {
                        /*passeDansLeTunel = true;*/
                        PORTA = 0b1100;
                   // }
                   // 
                }
                else if(rapport >= 80 /*&& passeDansLeTunel*/)
                {
                   /* passeDansLeTunel = false;
                    estSortiDuTunel = true;*/
                    PORTA = 0x00;
                }
               /* else if(estSortiDuTunel) //En gros on fait une intersection fancy
                {
                    _delay_ms(300); //Pour pas qu'il detecte trop tot et qu'il tourne dans le mur.
                    
                    if(compteur >= 3)// Comme ça si l'arrêt est à la sorti du tunnel bein c'est ça
                    {
                        moteur.Avance(0);
                        return 0;
                    }    
                    else if (directions[compteur] == 'd')
                    {
                        moteur.pivotDroit(150);
                        _delay_ms(250);
                    
                        while(!(bit1 || bit2 || bit3 || bit4 || bit5))
                        {
                            lireDirection();
                            moteur.Tourner_Gauche(170);
                        }
                        estSortiDuTunel = false;
                    

                    }
                    else if (directions[compteur] == 'g')
                    {
                        moteur.pivotGauche(150);
                        _delay_ms(250);
                        
                        while(!(bit1 || bit2 || bit3 || bit4 || bit5))
                        {
                            lireDirection();
                            moteur.Tourner_Gauche(170);
                        }
                        estSortiDuTunel = false;
                    }
                    compteur++;
                    tunelFini = true;
                    */    
                
         //   }
        /////////////////// FIN DES AJOUTS EXCITANTS ///////////////////////////
        
        
        if(bit1 && bit2 && bit3 && bit4 && bit5) // 1 1 1 1 1
        {
            if(compteur >= 3)
            {
                moteur.Avance(0);
                return 0;
            }
            else
                moteur.Avance(130);
        }
        
      /* else if(!bit1 && bit2 && bit3 && bit4 && !bit5) // Essai pour gerer l'intersection en triangle 0 1 1 1 0
        {
            
                if (directions[compteur] == 'd')
                {
                    moteur.pivotDroit(150);
                    _delay_ms(250);
              
                    while(!(bit1 || bit2 || bit3 || bit4 || bit5))
                    {
                        lireDirection();
                        moteur.Tourner_Gauche(170);
                    }
                                            
                }
                else if (directions[compteur] == 'g')
                {
                    moteur.pivotGauche(150);
                    _delay_ms(250);
                   
                    while(!(bit1 || bit2 || bit3 || bit4 || bit5))
                    {
                        lireDirection();
                        moteur.Tourner_Droite(170);
                    }		
   
                }
                                    
                    
                compteur++;
                //compteurIntersections++;
            
        }*/
        else if(bit1 && bit2 && !bit3 && !bit4 && !bit5) // 1 1 0 0 0
        {
            moteur.Tourner_Gauche(130);
        }
        else if(bit1 && !bit2 && !bit3 && !bit4 && !bit5) //1 0 0 0 0
        {
            moteur.pivotGauche(130);
        }
        else if(!bit1 && bit2 && !bit3 && !bit4 && !bit5) // 0 1 0 0 0
        {
            moteur.Tourner_Gauche(130);
        }
        else if(!(bit1) && !(bit2) && bit3 && bit4 && bit5) // 0 0 1 1 1
        {
            moteur.pivotDroit(130);
           // _delay_ms(300);
        }
        else if(bit1 && bit2 && bit3 && !(bit4) && !(bit5)) // 1 1 1 0 0
        {
            moteur.pivotGauche(130);
           // _delay_ms(300);
        }
        else if (!bit1 && !bit2 && !bit3 && !bit4 && bit5) //0 0 0 0 1
        {
            moteur.pivotDroit(130);
        }
        else if (!bit1 && !bit2 && !bit3 && bit4 && bit5) //0 0 0 1 1
        {
            moteur.Tourner_Droite(130);
        }
        else if (!bit1 && !bit2 && !bit3 && bit4 && !(bit5)) // 0 0 0 1 0
        {
            moteur.Tourner_Droite(130);
        }
        
	else if (!(bit1) && !(bit2) && bit3 && !bit4 && !bit5) // 0 0 1 0 0
	{
		moteur.Avance(130);
	}
	else if (!bit1 && bit2 && bit3 && !bit4 && !bit5) //0 1 1 0 0
	{
		moteur.Tourner_Gauche(130);
	}
	else if (!bit1 && !bit2 && bit3 && bit4 && !bit5) // 0 0 1 1 0
	{
		moteur.Tourner_Droite(130);
	}		
	else if (!bit1 && !bit2 && !bit3 && !bit4 && !bit5)	// 0 0 0 0 0
	{
			moteur.Avance(130);
			_delay_ms(500); // Peut-être à augmenter
			lireDirection();
                        
			if (!bit1 && !bit2 && !bit3 && !bit4 && !bit5) // INTERSECTION
			{
                            
                               
				if (directions[compteur] == 'd')
				{
					moteur.pivotDroit(150);
					_delay_ms(250);
					moteur.Avance(130);
					while(!(bit1 || bit2 || bit3 || bit4 || bit5))
					{
						lireDirection();
						
					}
					
                            
				}
				else if (directions[compteur] == 'g')
				{
					moteur.pivotGauche(150);
					_delay_ms(250);
					
					moteur.Avance(130);
					while(!(bit1 || bit2 || bit3 || bit4 || bit5))
					{
						lireDirection();
						
					}
					
				}
				
		
				compteur++;
			}
			/*else // POINTILLÉS
                        {
                            if(petitSkip < 2)
                                petitSkip++;
                            else
                            {
                                faireSon(100); 
                                petitSkip++;// Faudra vérifier la valeur... Aussi est-ce 
        }         //qu'on est oubligé de faire une montée? Si oui 
                                                //peut-être écrire les notes dans la mémoire...
                        }*/
			
        }
        else
        {
            moteur.Avance(0);
            del.allumerRouge(0);
        }
            
        
		
	
        
    }
    
    
    
}


/*
struct Tableau // Pour gerome collier
{
    uint8_t tableau[2];
};



void initialisationUART ( void ) {

// 2400 bauds. Nous vous donnons la valeur des deux

// premier registres pour vous éviter des complications

UBRR0H = 0;

UBRR0L = 0xCF;

// permettre la reception et la transmission par le UART0

UCSR0A = (1 << TXC0) | (1 << RXC0) ;

UCSR0B =  (1 << RXEN0) | (1 << TXEN0) ; // L'émetteur USART est activé en réglant TXEN dans UCSRB.

// Format des trames: 8 bits, 1 stop bits, none parity

UCSR0C = (1 << UCSZ00) | (1 << UCSZ01);

}

// De l'USART vers le PC


Tableau lecture(Memoire24CXXX& memoire, uint8_t& adresse)
{
	_delay_ms(5);
	uint8_t instruction[2] = {};
	memoire.lecture(adresse, instruction, 2);
	
        Tableau monTableau;
        monTableau.tableau[0] = instruction[0];
        monTableau.tableau[1] = instruction[1];
	return monTableau;
}
/*
uint8_t lecture(Memoire24CXXX& memoire, uint8_t& adresse)
{
	_delay_ms(5);
	uint8_t instruction[2] = {};
	memoire.lecture(adresse, instruction, 2);
	adresse += 2;
	
	return instruction[2];
}
*//*
void transmissionUARTVersPc ( uint8_t donnee ) {

	while (!( UCSR0A & (1<<UDRE0))) //Attendre que le tampon soient libre. 
	{
	}
               
    	UDR0 = donnee; 

}*/
/*
char transmissionPcVersUart ( ) {

	while (!( UCSR0A & (1<<RXC0)) && !(PIND & 0x04)) //
	{
	}
               
    	return UDR0;//Retourne le data recu par lwe buffer

}


void faireSon(unsigned int pwm)
{
        TCCR0A = (1 << WGM01) | (1 << COM0A0);
	
	TCCR0B = 0x04 ;
		
	OCR0A = 15625.0/(110.0 * pow(2, (pwm-45)/12.0));
}





*/
